import { derived, readonly, writable } from "svelte/store";
import { INTERNAL_DO_NOT_USE__fatalClientError, resolveMaybeUrlArg, unwrap, UploadAbortedError, UploadThingError, } from "@uploadthing/shared";
import { genUploader } from "uploadthing/client";
import { createFetch } from "./utils/createFetch";
const createRouteConfig = (url, endpoint) => {
    const dataGetter = createFetch(url.href);
    return derived(dataGetter, ($data) => $data.data?.find((x) => x.slug === endpoint)?.config);
};
export const INTERNAL_createUploadThingGen = (initOpts) => {
    const { uploadFiles, routeRegistry } = genUploader({
        url: initOpts.url,
        package: "@uploadthing/svelte",
    });
    const useUploadThing = (endpoint, opts) => {
        const isUploading = writable(false);
        let uploadProgress = 0;
        let fileProgress = new Map();
        const startUpload = async (...args) => {
            const files = (await opts?.onBeforeUploadBegin?.(args[0])) ?? args[0];
            const input = args[1];
            isUploading.set(true);
            opts?.onUploadProgress?.(0);
            files.forEach((f) => fileProgress.set(f, 0));
            try {
                const res = await uploadFiles(endpoint, {
                    signal: opts?.signal,
                    headers: opts?.headers,
                    files,
                    onUploadProgress: (progress) => {
                        if (!opts?.onUploadProgress)
                            return;
                        fileProgress.set(progress.file, progress.progress);
                        let sum = 0;
                        fileProgress.forEach((p) => {
                            sum += p;
                        });
                        const averageProgress = Math.floor(sum / fileProgress.size / 10) * 10;
                        if (averageProgress !== uploadProgress) {
                            opts?.onUploadProgress?.(averageProgress);
                            uploadProgress = averageProgress;
                        }
                    },
                    onUploadBegin({ file }) {
                        if (!opts?.onUploadBegin)
                            return;
                        opts.onUploadBegin(file);
                    },
                    // @ts-expect-error - input may not be defined on the type
                    input,
                });
                await opts?.onClientUploadComplete?.(res);
                return res;
            }
            catch (e) {
                /**
                 * This is the only way to introduce this as a non-breaking change
                 * TODO: Consider refactoring API in the next major version
                 */
                if (e instanceof UploadAbortedError)
                    throw e;
                let error;
                if (e instanceof UploadThingError) {
                    error = e;
                }
                else {
                    error = INTERNAL_DO_NOT_USE__fatalClientError(e);
                    console.error("Something went wrong. Please contact UploadThing and provide the following cause:", error.cause instanceof Error ? error.cause.toString() : error.cause);
                }
                await opts?.onUploadError?.(error);
            }
            finally {
                isUploading.set(false);
                fileProgress = new Map();
                uploadProgress = 0;
            }
        };
        const _endpoint = unwrap(endpoint, routeRegistry);
        const routeConfig = createRouteConfig(initOpts.url, _endpoint);
        return {
            startUpload,
            isUploading: readonly(isUploading),
            routeConfig,
            /**
             * @deprecated Use `routeConfig` instead
             */
            permittedFileInfo: routeConfig
                ? { slug: _endpoint, config: readonly(routeConfig) }
                : undefined,
        };
    };
    return useUploadThing;
};
const generateUploader = () => {
    return (endpoint, props) => ({ endpoint, ...props });
};
export const generateSvelteHelpers = (initOpts) => {
    const url = resolveMaybeUrlArg(initOpts?.url);
    return {
        createUploadThing: INTERNAL_createUploadThingGen({ url }),
        createUploader: generateUploader(),
        ...genUploader({
            url,
            package: "@uploadthing/svelte",
        }),
    };
};
